name: Deploy to VPS

on:
  push:
    branches: [ feature ]
  workflow_dispatch:

env:
  DOTNET_VERSION: '8.0.x'

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Validate required secrets
        run: |
          echo "Validating required secrets..."
          MISSING_SECRETS=""

          [ -z "$ALLOWED_ORIGINS" ] && MISSING_SECRETS="$MISSING_SECRETS ALLOWED_ORIGINS"
          [ -z "$DB_CONNECTION_STRING_USERS" ] && MISSING_SECRETS="$MISSING_SECRETS DB_CONNECTION_STRING_USERS"
          [ -z "$JWT_SECRET_KEY" ] && MISSING_SECRETS="$MISSING_SECRETS JWT_SECRET_KEY"
          [ -z "$RABBITMQ_HOST" ] && MISSING_SECRETS="$MISSING_SECRETS RABBITMQ_HOST"

          if [ -n "$MISSING_SECRETS" ]; then
            echo "ERROR: Missing required secrets:$MISSING_SECRETS"
            echo "Please set these secrets in GitHub repository settings"
            exit 1
          fi

          echo "✅ All required secrets are set"
        env:
          ALLOWED_ORIGINS: ${{ secrets.ALLOWED_ORIGINS }}
          DB_CONNECTION_STRING_USERS: ${{ secrets.DB_CONNECTION_STRING_USERS }}
          JWT_SECRET_KEY: ${{ secrets.JWT_SECRET_KEY }}
          RABBITMQ_HOST: ${{ secrets.RABBITMQ_HOST }}

      - name: Create Firebase credentials JSON file
        run: |
          cd basms-be

          python3 << 'PYTHON_SCRIPT'
          import json
          import os

          firebase_creds = {
              "type": "service_account",
              "project_id": os.environ.get('FIREBASE_PROJECT_ID', ''),
              "private_key_id": os.environ.get('FIREBASE_PRIVATE_KEY_ID', ''),
              "private_key": os.environ.get('FIREBASE_PRIVATE_KEY', '').replace('\\n', '\n'),
              "client_email": os.environ.get('FIREBASE_CLIENT_EMAIL', ''),
              "client_id": os.environ.get('FIREBASE_CLIENT_ID', ''),
              "auth_uri": "https://accounts.google.com/o/oauth2/auth",
              "token_uri": "https://oauth2.googleapis.com/token",
              "auth_provider_x509_cert_url": "https://www.googleapis.com/oauth2/v1/certs",
              "client_x509_cert_url": os.environ.get('FIREBASE_CLIENT_CERT_URL', '')
          }

          with open('firebase-credentials.json', 'w') as f:
              json.dump(firebase_creds, f, indent=2)

          print("✅ Firebase credentials file created successfully")
          PYTHON_SCRIPT

          if [ -f firebase-credentials.json ]; then
            echo "✅ firebase-credentials.json created"
            FILE_SIZE=$(wc -c < firebase-credentials.json)
            echo "File size: $FILE_SIZE bytes"

            if grep -q "BEGIN PRIVATE KEY" firebase-credentials.json; then
              echo "✅ Private key format is correct"
            else
              echo "❌ ERROR: Private key format is incorrect!"
              exit 1
            fi
          else
            echo "❌ ERROR: firebase-credentials.json not created!"
            exit 1
          fi
        env:
          FIREBASE_PROJECT_ID: ${{ secrets.FIREBASE_PROJECT_ID }}
          FIREBASE_PRIVATE_KEY_ID: ${{ secrets.FIREBASE_PRIVATE_KEY_ID }}
          FIREBASE_PRIVATE_KEY: ${{ secrets.FIREBASE_PRIVATE_KEY }}
          FIREBASE_CLIENT_EMAIL: ${{ secrets.FIREBASE_CLIENT_EMAIL }}
          FIREBASE_CLIENT_ID: ${{ secrets.FIREBASE_CLIENT_ID }}
          FIREBASE_CLIENT_CERT_URL: ${{ secrets.FIREBASE_CLIENT_CERT_URL }}

      - name: Create .env file for Docker Compose
        run: |
          cd basms-be

          python3 << 'PYTHON_SCRIPT'
          import os

          # Get all environment variables directly from secrets
          env_vars = {
              'MYSQL_ROOT_PASSWORD': os.environ.get('MYSQL_ROOT_PASSWORD', ''),
              'MYSQL_USER_PASSWORD': os.environ.get('MYSQL_USER_PASSWORD', ''),
              'DB_CONNECTION_STRING_USERS': os.environ.get('DB_CONNECTION_STRING_USERS', ''),
              'DB_CONNECTION_STRING_CONTRACTS': os.environ.get('DB_CONNECTION_STRING_CONTRACTS', ''),
              'DB_CONNECTION_STRING_SHIFTS': os.environ.get('DB_CONNECTION_STRING_SHIFTS', ''),
              'DB_CONNECTION_STRING_ATTENDANCES': os.environ.get('DB_CONNECTION_STRING_ATTENDANCES', ''),
              'DB_CONNECTION_STRING_CHATS': os.environ.get('DB_CONNECTION_STRING_CHATS', ''),
              'DB_CONNECTION_STRING_INCIDENTS': os.environ.get('DB_CONNECTION_STRING_INCIDENTS', ''),
              'FIREBASE_API_KEY': os.environ.get('FIREBASE_API_KEY', ''),
              'FIREBASE_URL': os.environ.get('FIREBASE_URL', ''),
              'EMAIL_SENDER': os.environ.get('EMAIL_SENDER', ''),
              'EMAIL_PASSWORD': os.environ.get('EMAIL_PASSWORD', ''),
              'JWT_SECRET_KEY': os.environ.get('JWT_SECRET_KEY', ''),
              'JWT_ISSUER': os.environ.get('JWT_ISSUER', ''),
              'JWT_AUDIENCE': os.environ.get('JWT_AUDIENCE', ''),
              'RABBITMQ_HOST': 'rabbitmq',
              'RABBITMQ_USERNAME': os.environ.get('RABBITMQ_USERNAME', ''),
              'RABBITMQ_PASSWORD': os.environ.get('RABBITMQ_PASSWORD', ''),
              'AWS_BUCKET_NAME': os.environ.get('AWS_BUCKET_NAME', ''),
              'AWS_BUCKET_FACEID_NAME': os.environ.get('AWS_BUCKET_FACEID_NAME', ''),
              'AWS_BUCKET_FILE_NAME': os.environ.get('AWS_BUCKET_FILE_NAME', ''),
              'AWS_REGION': os.environ.get('AWS_REGION', ''),
              'AWS_ACCESS_KEY': os.environ.get('AWS_ACCESS_KEY', ''),
              'AWS_SECRET_KEY': os.environ.get('AWS_SECRET_KEY', ''),
              'SIGNATURE_CERT_PATH': os.environ.get('SIGNATURE_CERT_PATH', ''),
              'SIGNATURE_CERT_PASSWORD': os.environ.get('SIGNATURE_CERT_PASSWORD', ''),
              'HERE_API_KEY': os.environ.get('HERE_API_KEY', ''),
              'ALLOWED_ORIGINS': os.environ.get('ALLOWED_ORIGINS', ''),
              'GOOGLE_APPLICATION_CREDENTIALS': '/app/config/firebase-credentials.json',
              'FACEID_API_BASE_URL': os.environ.get('FACEID_API_BASE_URL', '')
          }

          # Write .env.production file WITHOUT quotes (Docker Compose handles this better)
          with open('.env.production', 'w') as f:
              for key, value in env_vars.items():
                  # Escape special characters for .env file
                  # Replace $ with $$ to prevent Docker Compose variable expansion
                  escaped_value = value.replace('$', '$$').replace('\\', '\\\\')
                  f.write(f'{key}={escaped_value}\n')

          print("✅ .env.production file created successfully")
          PYTHON_SCRIPT

          echo ".env.production file created"
          echo "Verifying .env.production file..."
          if [ -f .env.production ]; then
            FILE_SIZE=$(wc -c < .env.production)
            echo "File exists, size: $FILE_SIZE bytes"

            if [ "$FILE_SIZE" -lt 100 ]; then
              echo "WARNING: File size is too small! Secrets might be empty."
              echo "Content preview:"
              cat .env.production | sed 's/=.*/=***/'
              exit 1
            fi

            echo "First few lines (masked):"
            head -5 .env.production | sed 's/=.*/=***/'
          else
            echo "ERROR: .env.production file not created!"
            exit 1
          fi
        env:
          MYSQL_ROOT_PASSWORD: ${{ secrets.MYSQL_ROOT_PASSWORD }}
          MYSQL_USER_PASSWORD: ${{ secrets.MYSQL_USER_PASSWORD }}
          DB_CONNECTION_STRING_USERS: ${{ secrets.DB_CONNECTION_STRING_USERS }}
          DB_CONNECTION_STRING_CONTRACTS: ${{ secrets.DB_CONNECTION_STRING_CONTRACTS }}
          DB_CONNECTION_STRING_SHIFTS: ${{ secrets.DB_CONNECTION_STRING_SHIFTS }}
          DB_CONNECTION_STRING_ATTENDANCES: ${{ secrets.DB_CONNECTION_STRING_ATTENDANCES }}
          DB_CONNECTION_STRING_CHATS: ${{ secrets.DB_CONNECTION_STRING_CHATS }}
          DB_CONNECTION_STRING_INCIDENTS: ${{ secrets.DB_CONNECTION_STRING_INCIDENTS }}
          FIREBASE_API_KEY: ${{ secrets.FIREBASE_API_KEY }}
          FIREBASE_URL: ${{ secrets.FIREBASE_URL }}
          EMAIL_SENDER: ${{ secrets.EMAIL_SENDER }}
          EMAIL_PASSWORD: ${{ secrets.EMAIL_PASSWORD }}
          JWT_SECRET_KEY: ${{ secrets.JWT_SECRET_KEY }}
          JWT_ISSUER: ${{ secrets.JWT_ISSUER }}
          JWT_AUDIENCE: ${{ secrets.JWT_AUDIENCE }}
          RABBITMQ_USERNAME: ${{ secrets.RABBITMQ_USERNAME }}
          RABBITMQ_PASSWORD: ${{ secrets.RABBITMQ_PASSWORD }}
          AWS_BUCKET_NAME: ${{ secrets.AWS_BUCKET_NAME }}
          AWS_BUCKET_FACEID_NAME: ${{ secrets.AWS_BUCKET_FACEID_NAME }}
          AWS_BUCKET_FILE_NAME: ${{ secrets.AWS_BUCKET_FILE_NAME }}
          AWS_REGION: ${{ secrets.AWS_REGION }}
          AWS_ACCESS_KEY: ${{ secrets.AWS_ACCESS_KEY }}
          AWS_SECRET_KEY: ${{ secrets.AWS_SECRET_KEY }}
          SIGNATURE_CERT_PATH: ${{ secrets.SIGNATURE_CERT_PATH }}
          SIGNATURE_CERT_PASSWORD: ${{ secrets.SIGNATURE_CERT_PASSWORD }}
          HERE_API_KEY: ${{ secrets.HERE_API_KEY }}
          ALLOWED_ORIGINS: ${{ secrets.ALLOWED_ORIGINS }}
          FACEID_API_BASE_URL: ${{ secrets.FACEID_API_BASE_URL }}

      - name: Create deployment package
        run: |
          tar -czf basms-backend.tar.gz \
            --exclude='basms-be/bin' \
            --exclude='basms-be/obj' \
            --exclude='basms-be/.git' \
            --exclude='basms-be/.vs' \
            --exclude='basms-be/*.user' \
            --exclude='basms-be/publish' \
            --exclude='basms-be/**/bin' \
            --exclude='basms-be/**/obj' \
            --exclude='basms-be/compose.yaml' \
            -C basms-be .
          echo "Deployment package created: basms-backend.tar.gz"

      - name: Upload to VPS
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.VPS_HOST }}
          username: ${{ secrets.VPS_USERNAME }}
          key: ${{ secrets.VPS_SSH_KEY }}
          port: ${{ secrets.VPS_SSH_PORT || 22 }}
          source: "basms-backend.tar.gz"
          target: "/tmp/"

      - name: Deploy on VPS with Docker Compose
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.VPS_HOST }}
          username: ${{ secrets.VPS_USERNAME }}
          key: ${{ secrets.VPS_SSH_KEY }}
          port: ${{ secrets.VPS_SSH_PORT || 22 }}
          script: |
            echo "Starting deployment on VPS..."

            # Create deployment directory
            mkdir -p ~/basms

            # Backup old deployment
            if [ -d ~/basms/old ]; then
              rm -rf ~/basms/old
            fi
            if [ -d ~/basms/current ]; then
              mv ~/basms/current ~/basms/old
            fi

            # Create new deployment directory
            mkdir -p ~/basms/current

            # Extract the package
            cd ~/basms/current
            tar -xzf /tmp/basms-backend.tar.gz 2>/dev/null || true

            # Remove compose.yaml if exists
            if [ -f compose.yaml ]; then
              echo "Removing compose.yaml to avoid conflict with docker-compose.yml"
              rm -f compose.yaml
            fi

            # Setup .env file
            if [ -f .env.production ]; then
              mv .env.production .env
              echo "✅ .env file created from .env.production"
              echo "File size: $(wc -c < .env) bytes"
              echo "Number of variables: $(grep -c '=' .env || echo 0)"

              echo "Verifying critical environment variables..."
              for var in ALLOWED_ORIGINS DB_CONNECTION_STRING_USERS JWT_SECRET_KEY RABBITMQ_HOST GOOGLE_APPLICATION_CREDENTIALS; do
                if grep -q "^${var}=" .env; then
                  echo "✅ $var is set"
                else
                  echo "❌ WARNING: $var is missing!"
                fi
              done
            else
              echo "❌ ERROR: .env.production not found!"
              exit 1
            fi

            # Setup Firebase credentials
            mkdir -p ~/basms/config
            if [ -f firebase-credentials.json ]; then
              mv firebase-credentials.json ~/basms/config/
              echo "✅ Firebase credentials moved to ~/basms/config/"

              if grep -q "BEGIN PRIVATE KEY" ~/basms/config/firebase-credentials.json; then
                echo "✅ Firebase credentials file format is correct"
              else
                echo "❌ WARNING: Firebase credentials format might be incorrect!"
              fi
            else
              echo "❌ WARNING: firebase-credentials.json not found!"
            fi
            # Stop existing containers (exclude Face API and MySQL)
            echo "Stopping and removing existing C# API containers..."
            cd ~/basms/current
            
            # Stop only C# API containers, preserve Face API and MySQL
            for service in users-api contracts-api shifts-api attendances-api chats-api incidents-api rabbitmq; do
              echo "Stopping $service..."
              docker compose stop $service 2>/dev/null || true
              docker compose rm -f $service 2>/dev/null || true
            done
            
            # Note: MySQL volume and Face API container are NOT removed to preserve data/state

            # Remove only basms-* containers (excluding basms-face-api and basms-mysql)
            echo "Removing orphan basms-* containers (excluding Face API and MySQL)..."
            docker ps -a --filter "name=basms-" --format "{{.Names}}" | grep -v -E "(face|mysql)" | xargs -r docker rm -f 2>/dev/null || echo "No orphan containers found"

            # Clean up old images
            echo "Cleaning up old Docker images..."
            docker image prune -af --filter "until=24h" 2>/dev/null || true

            # Clean up unused volumes
            echo "Cleaning up unused volumes..."
            docker volume prune -f 2>/dev/null || true

            # Verify docker-compose.yml exists
            if [ ! -f docker-compose.yml ]; then
              echo "❌ ERROR: docker-compose.yml not found!"
              ls -la
              exit 1
            fi
            echo "✅ docker-compose.yml found"

            # Debug: Show .env file content (masked)
            echo "=== DEBUG: .env file content (first 10 lines, values masked) ==="
            if [ -f .env ]; then
              head -10 .env | sed 's/=.*/=***/'
              echo "Total lines in .env: $(wc -l < .env)"
              echo "Total size: $(wc -c < .env) bytes"
            else
              echo "❌ ERROR: .env file not found!"
              exit 1
            fi

            # Test docker compose config
            echo "=== Testing Docker Compose configuration ==="
            if docker compose config > /dev/null 2>&1; then
              echo "✅ Docker Compose config is valid"
            else
              echo "❌ ERROR: Docker Compose config is invalid!"
              docker compose config
              exit 1
            fi

            # Build Docker images
            echo "Building Docker images..."
            if ! docker compose build --no-cache; then
              echo "❌ ERROR: Docker build failed!"
              docker compose logs
              exit 1
            fi
            echo "✅ Docker images built successfully"

            # Start services
            echo "Starting services with Docker Compose..."
            # Note: Do NOT use --remove-orphans to preserve Face API and other standalone containers
            if ! docker compose up -d; then
              echo "❌ ERROR: Docker compose up failed!"
              echo "=== Docker Compose Logs ==="
              docker compose logs
              echo "=== Docker Compose Config ==="
              docker compose config
              exit 1
            fi
            echo "✅ Services started"

            # Wait for services to start
            echo "Waiting for services to start..."
            sleep 15

            # Check service status
            echo "=== Service status ==="
            docker compose ps -a

            # Show container status with more details
            echo "=== All containers ==="
            docker ps -a --filter "name=basms"

            # Show recent logs for each service
            echo "=== Recent logs ==="
            docker compose logs --tail=50 --timestamps

            # Cleanup
            rm -f /tmp/basms-backend.tar.gz
            echo "✅ Deployment completed successfully!"

      - name: Notify deployment status
        if: always()
        run: |
          if [ "${{ job.status }}" == "success" ]; then
            echo "✅ Deployment to VPS completed successfully!"
          else
            echo "❌ Deployment failed! Please check the logs."
          fi
