name: Deploy to VPS

on:
  push:
    branches: [ feature ]
  workflow_dispatch:

env:
  DOTNET_VERSION: '8.0.x'

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Create .env file for Docker Compose
      run: |
        cd basms-be

        cat > .env.production << EOF
        MYSQL_ROOT_PASSWORD=${{ secrets.MYSQL_ROOT_PASSWORD }}
        DB_CONNECTION_STRING_USERS=${{ secrets.DB_CONNECTION_STRING_USERS }}
        DB_CONNECTION_STRING_CONTRACTS=${{ secrets.DB_CONNECTION_STRING_CONTRACTS }}
        DB_CONNECTION_STRING_SHIFTS=${{ secrets.DB_CONNECTION_STRING_SHIFTS }}
        FIREBASE_API_KEY=${{ secrets.FIREBASE_API_KEY }}
        FIREBASE_URL=${{ secrets.FIREBASE_URL }}
        FIREBASE_PROJECT_ID=${{ secrets.FIREBASE_PROJECT_ID }}
        FIREBASE_PRIVATE_KEY_ID=${{ secrets.FIREBASE_PRIVATE_KEY_ID }}
        FIREBASE_PRIVATE_KEY=${{ secrets.FIREBASE_PRIVATE_KEY }}
        FIREBASE_CLIENT_EMAIL=${{ secrets.FIREBASE_CLIENT_EMAIL }}
        FIREBASE_CLIENT_ID=${{ secrets.FIREBASE_CLIENT_ID }}
        FIREBASE_CLIENT_CERT_URL=${{ secrets.FIREBASE_CLIENT_CERT_URL }}
        EMAIL_SENDER=${{ secrets.EMAIL_SENDER }}
        EMAIL_PASSWORD=${{ secrets.EMAIL_PASSWORD }}
        JWT_SECRET_KEY=${{ secrets.JWT_SECRET_KEY }}
        JWT_ISSUER=${{ secrets.JWT_ISSUER }}
        JWT_AUDIENCE=${{ secrets.JWT_AUDIENCE }}
        RABBITMQ_HOST=${{ secrets.RABBITMQ_HOST }}
        RABBITMQ_USERNAME=${{ secrets.RABBITMQ_USERNAME }}
        RABBITMQ_PASSWORD=${{ secrets.RABBITMQ_PASSWORD }}
        AWS_BUCKET_NAME=${{ secrets.AWS_BUCKET_NAME }}
        AWS_REGION=${{ secrets.AWS_REGION }}
        AWS_ACCESS_KEY=${{ secrets.AWS_ACCESS_KEY }}
        AWS_SECRET_KEY=${{ secrets.AWS_SECRET_KEY }}
        SIGNATURE_CERT_PATH=${{ secrets.SIGNATURE_CERT_PATH }}
        SIGNATURE_CERT_PASSWORD=${{ secrets.SIGNATURE_CERT_PASSWORD }}
        GOONG_API_KEY=${{ secrets.GOONG_API_KEY }}
        ALLOWED_ORIGINS=${{ secrets.ALLOWED_ORIGINS }}
        EOF

        echo ".env.production file created"
        echo "Verifying .env.production file..."
        if [ -f .env.production ]; then
          echo "File exists, size: $(wc -c < .env.production) bytes"
          echo "First few lines (masked):"
          head -3 .env.production | sed 's/=.*/=***/'
        else
          echo "ERROR: .env.production file not created!"
          exit 1
        fi

    - name: Create deployment package
      run: |
        tar -czf basms-backend.tar.gz \
          --exclude='basms-be/bin' \
          --exclude='basms-be/obj' \
          --exclude='basms-be/.git' \
          --exclude='basms-be/.vs' \
          --exclude='basms-be/*.user' \
          --exclude='basms-be/publish' \
          --exclude='basms-be/**/bin' \
          --exclude='basms-be/**/obj' \
          -C basms-be .
        echo "Deployment package created: basms-backend.tar.gz"

    - name: Upload to VPS
      uses: appleboy/scp-action@v0.1.7
      with:
        host: ${{ secrets.VPS_HOST }}
        username: ${{ secrets.VPS_USERNAME }}
        key: ${{ secrets.VPS_SSH_KEY }}
        port: ${{ secrets.VPS_SSH_PORT || 22 }}
        source: "basms-backend.tar.gz"
        target: "/tmp/"

    - name: Deploy on VPS with Docker Compose
      uses: appleboy/ssh-action@v1.0.3
      with:
        host: ${{ secrets.VPS_HOST }}
        username: ${{ secrets.VPS_USERNAME }}
        key: ${{ secrets.VPS_SSH_KEY }}
        port: ${{ secrets.VPS_SSH_PORT || 22 }}
        script: |
          echo "Starting deployment on VPS..."

          # Create deployment directory if not exists
          mkdir -p ~/basms

          # Backup old deployment
          if [ -d ~/basms/old ]; then
            rm -rf ~/basms/old
          fi
          if [ -d ~/basms/current ]; then
            mv ~/basms/current ~/basms/old
          fi

          # Create new deployment directory
          mkdir -p ~/basms/current

          # Extract the package
          cd ~/basms/current
          tar -xzf /tmp/basms-backend.tar.gz

          # Rename .env.production to .env for Docker Compose
          if [ -f .env.production ]; then
            mv .env.production .env
            echo ".env file created from .env.production"
            echo "File size: $(wc -c < .env) bytes"
            echo "Number of variables: $(grep -c '=' .env || echo 0)"

            # Verify critical variables exist
            echo "Verifying critical environment variables..."
            for var in ALLOWED_ORIGINS DB_CONNECTION_STRING_USERS JWT_SECRET_KEY RABBITMQ_HOST; do
              if grep -q "^${var}=" .env; then
                echo "✓ $var is set"
              else
                echo "✗ WARNING: $var is missing!"
              fi
            done
          else
            echo "ERROR: .env.production not found!"
            exit 1
          fi

          # Stop existing containers
          echo "Stopping existing containers..."
          cd ~/basms/current
          docker compose down || echo "No containers to stop"

          # Remove old images to free up space
          echo "Cleaning up old Docker images..."
          docker image prune -af --filter "until=24h" || true

          # Build Docker images
          echo "Building Docker images..."
          docker compose build --no-cache

          # Start services with Docker Compose
          echo "Starting services with Docker Compose..."
          docker compose up -d

          # Wait for services to be healthy
          echo "Waiting for services to start..."
          sleep 10

          # Check service status
          echo "Service status:"
          docker compose ps

          # Show logs
          echo "Recent logs:"
          docker compose logs --tail=50

          # Cleanup
          rm -f /tmp/basms-backend.tar.gz
          echo "Deployment completed successfully!"

    - name: Notify deployment status
      if: always()
      run: |
        if [ ${{ job.status }} == 'success' ]; then
          echo "Deployment to VPS completed successfully!"
        else
          echo "Deployment failed! Please check the logs."
        fi
