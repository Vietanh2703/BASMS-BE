name: Deploy to VPS

on:
  push:
    branches: [ feature ]
  workflow_dispatch:

env:
  DOTNET_VERSION: '8.0.x'

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Create .env file for Docker Compose
      env:
        ALLOWED_ORIGINS: ${{ secrets.ALLOWED_ORIGINS }}
        DB_CONNECTION_STRING_USERS: ${{ secrets.DB_CONNECTION_STRING_USERS }}
        DB_CONNECTION_STRING_CONTRACTS: ${{ secrets.DB_CONNECTION_STRING_CONTRACTS }}
        DB_CONNECTION_STRING_SHIFTS: ${{ secrets.DB_CONNECTION_STRING_SHIFTS }}
        FIREBASE_API_KEY: ${{ secrets.FIREBASE_API_KEY }}
        FIREBASE_URL: ${{ secrets.FIREBASE_URL }}
        FIREBASE_PROJECT_ID: ${{ secrets.FIREBASE_PROJECT_ID }}
        FIREBASE_PRIVATE_KEY_ID: ${{ secrets.FIREBASE_PRIVATE_KEY_ID }}
        FIREBASE_PRIVATE_KEY: ${{ secrets.FIREBASE_PRIVATE_KEY }}
        FIREBASE_CLIENT_EMAIL: ${{ secrets.FIREBASE_CLIENT_EMAIL }}
        FIREBASE_CLIENT_ID: ${{ secrets.FIREBASE_CLIENT_ID }}
        FIREBASE_CLIENT_CERT_URL: ${{ secrets.FIREBASE_CLIENT_CERT_URL }}
        EMAIL_SENDER: ${{ secrets.EMAIL_SENDER }}
        EMAIL_PASSWORD: ${{ secrets.EMAIL_PASSWORD }}
        JWT_SECRET_KEY: ${{ secrets.JWT_SECRET_KEY }}
        JWT_ISSUER: ${{ secrets.JWT_ISSUER }}
        JWT_AUDIENCE: ${{ secrets.JWT_AUDIENCE }}
        RABBITMQ_HOST: ${{ secrets.RABBITMQ_HOST }}
        RABBITMQ_USERNAME: ${{ secrets.RABBITMQ_USERNAME }}
        RABBITMQ_PASSWORD: ${{ secrets.RABBITMQ_PASSWORD }}
        AWS_BUCKET_NAME: ${{ secrets.AWS_BUCKET_NAME }}
        AWS_REGION: ${{ secrets.AWS_REGION }}
        AWS_ACCESS_KEY: ${{ secrets.AWS_ACCESS_KEY }}
        AWS_SECRET_KEY: ${{ secrets.AWS_SECRET_KEY }}
        SIGNATURE_CERT_PATH: ${{ secrets.SIGNATURE_CERT_PATH }}
        SIGNATURE_CERT_PASSWORD: ${{ secrets.SIGNATURE_CERT_PASSWORD }}
        GOONG_API_KEY: ${{ secrets.GOONG_API_KEY }}
        MYSQL_ROOT_PASSWORD: ${{ secrets.MYSQL_ROOT_PASSWORD }}
      run: |
        cd basms-be

        cat > .env.production << 'EOF'
        # Database
        MYSQL_ROOT_PASSWORD=${{ secrets.MYSQL_ROOT_PASSWORD }}
        DB_CONNECTION_STRING_USERS=${{ secrets.DB_CONNECTION_STRING_USERS }}
        DB_CONNECTION_STRING_CONTRACTS=${{ secrets.DB_CONNECTION_STRING_CONTRACTS }}
        DB_CONNECTION_STRING_SHIFTS=${{ secrets.DB_CONNECTION_STRING_SHIFTS }}

        # Firebase
        FIREBASE_API_KEY=${{ secrets.FIREBASE_API_KEY }}
        FIREBASE_URL=${{ secrets.FIREBASE_URL }}
        FIREBASE_PROJECT_ID=${{ secrets.FIREBASE_PROJECT_ID }}
        FIREBASE_PRIVATE_KEY_ID=${{ secrets.FIREBASE_PRIVATE_KEY_ID }}
        FIREBASE_PRIVATE_KEY=${{ secrets.FIREBASE_PRIVATE_KEY }}
        FIREBASE_CLIENT_EMAIL=${{ secrets.FIREBASE_CLIENT_EMAIL }}
        FIREBASE_CLIENT_ID=${{ secrets.FIREBASE_CLIENT_ID }}
        FIREBASE_CLIENT_CERT_URL=${{ secrets.FIREBASE_CLIENT_CERT_URL }}

        # Email
        EMAIL_SENDER=${{ secrets.EMAIL_SENDER }}
        EMAIL_PASSWORD=${{ secrets.EMAIL_PASSWORD }}

        # JWT
        JWT_SECRET_KEY=${{ secrets.JWT_SECRET_KEY }}
        JWT_ISSUER=${{ secrets.JWT_ISSUER }}
        JWT_AUDIENCE=${{ secrets.JWT_AUDIENCE }}

        # RabbitMQ
        RABBITMQ_HOST=${{ secrets.RABBITMQ_HOST }}
        RABBITMQ_USERNAME=${{ secrets.RABBITMQ_USERNAME }}
        RABBITMQ_PASSWORD=${{ secrets.RABBITMQ_PASSWORD }}

        # AWS
        AWS_BUCKET_NAME=${{ secrets.AWS_BUCKET_NAME }}
        AWS_REGION=${{ secrets.AWS_REGION }}
        AWS_ACCESS_KEY=${{ secrets.AWS_ACCESS_KEY }}
        AWS_SECRET_KEY=${{ secrets.AWS_SECRET_KEY }}

        # Signature
        SIGNATURE_CERT_PATH=${{ secrets.SIGNATURE_CERT_PATH }}
        SIGNATURE_CERT_PASSWORD=${{ secrets.SIGNATURE_CERT_PASSWORD }}

        # Goong API
        GOONG_API_KEY=${{ secrets.GOONG_API_KEY }}

        # CORS
        ALLOWED_ORIGINS=${{ secrets.ALLOWED_ORIGINS }}
        EOF

        echo ".env.production file created"

    - name: Create deployment package
      run: |
        tar -czf basms-backend.tar.gz \
          --exclude='basms-be/bin' \
          --exclude='basms-be/obj' \
          --exclude='basms-be/.git' \
          --exclude='basms-be/.vs' \
          --exclude='basms-be/*.user' \
          --exclude='basms-be/publish' \
          --exclude='basms-be/**/bin' \
          --exclude='basms-be/**/obj' \
          -C basms-be .
        echo "Deployment package created: basms-backend.tar.gz"

    - name: Upload to VPS
      uses: appleboy/scp-action@v0.1.7
      with:
        host: ${{ secrets.VPS_HOST }}
        username: ${{ secrets.VPS_USERNAME }}
        key: ${{ secrets.VPS_SSH_KEY }}
        port: ${{ secrets.VPS_SSH_PORT || 22 }}
        source: "basms-backend.tar.gz"
        target: "/tmp/"

    - name: Deploy on VPS with Docker Compose
      uses: appleboy/ssh-action@v1.0.3
      with:
        host: ${{ secrets.VPS_HOST }}
        username: ${{ secrets.VPS_USERNAME }}
        key: ${{ secrets.VPS_SSH_KEY }}
        port: ${{ secrets.VPS_SSH_PORT || 22 }}
        script: |
          echo "Starting deployment on VPS..."

          # Create deployment directory if not exists
          mkdir -p ~/basms

          # Backup old deployment
          if [ -d ~/basms/old ]; then
            rm -rf ~/basms/old
          fi
          if [ -d ~/basms/current ]; then
            mv ~/basms/current ~/basms/old
          fi

          # Create new deployment directory
          mkdir -p ~/basms/current

          # Extract the package
          cd ~/basms/current
          tar -xzf /tmp/basms-backend.tar.gz

          # Rename .env.production to .env for Docker Compose
          if [ -f .env.production ]; then
            mv .env.production .env
            echo ".env file created from .env.production"
          else
            echo "Warning: .env.production not found!"
          fi

          # Stop existing containers
          echo "Stopping existing containers..."
          cd ~/basms/current
          docker compose down || echo "No containers to stop"

          # Remove old images to free up space
          echo "Cleaning up old Docker images..."
          docker image prune -af --filter "until=24h" || true

          # Build Docker images
          echo "Building Docker images..."
          docker compose build --no-cache

          # Start services with Docker Compose
          echo "Starting services with Docker Compose..."
          docker compose up -d

          # Wait for services to be healthy
          echo "Waiting for services to start..."
          sleep 10

          # Check service status
          echo "Service status:"
          docker compose ps

          # Show logs
          echo "Recent logs:"
          docker compose logs --tail=50

          # Cleanup
          rm -f /tmp/basms-backend.tar.gz
          echo "Deployment completed successfully!"

    - name: Notify deployment status
      if: always()
      run: |
        if [ ${{ job.status }} == 'success' ]; then
          echo "Deployment to VPS completed successfully!"
        else
          echo "Deployment failed! Please check the logs."
        fi
